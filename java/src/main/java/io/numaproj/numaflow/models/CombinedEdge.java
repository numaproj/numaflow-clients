/*
 * Numaflow
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.2.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.numaproj.numaflow.models;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.numaproj.numaflow.models.ForwardConditions;
import io.numaproj.numaflow.models.VertexLimits;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


import io.numaproj.numaflow.ApiClient;
/**
 * CombinedEdge is a combination of Edge and some other properties such as vertex type, partitions, limits. It&#39;s used to decorate the fromEdges and toEdges of the generated Vertex objects, so that in the vertex pod, it knows the properties of the connected vertices, for example, how many partitioned buffers I should write to, what is the write buffer length, etc.
 */
@JsonPropertyOrder({
  CombinedEdge.JSON_PROPERTY_CONDITIONS,
  CombinedEdge.JSON_PROPERTY_FROM,
  CombinedEdge.JSON_PROPERTY_FROM_VERTEX_LIMITS,
  CombinedEdge.JSON_PROPERTY_FROM_VERTEX_PARTITION_COUNT,
  CombinedEdge.JSON_PROPERTY_FROM_VERTEX_TYPE,
  CombinedEdge.JSON_PROPERTY_ON_FULL,
  CombinedEdge.JSON_PROPERTY_TO,
  CombinedEdge.JSON_PROPERTY_TO_VERTEX_LIMITS,
  CombinedEdge.JSON_PROPERTY_TO_VERTEX_PARTITION_COUNT,
  CombinedEdge.JSON_PROPERTY_TO_VERTEX_TYPE
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.7.0")
public class CombinedEdge {
  public static final String JSON_PROPERTY_CONDITIONS = "conditions";
  private ForwardConditions conditions;

  public static final String JSON_PROPERTY_FROM = "from";
  private String from;

  public static final String JSON_PROPERTY_FROM_VERTEX_LIMITS = "fromVertexLimits";
  private VertexLimits fromVertexLimits;

  public static final String JSON_PROPERTY_FROM_VERTEX_PARTITION_COUNT = "fromVertexPartitionCount";
  private Integer fromVertexPartitionCount;

  public static final String JSON_PROPERTY_FROM_VERTEX_TYPE = "fromVertexType";
  private String fromVertexType;

  public static final String JSON_PROPERTY_ON_FULL = "onFull";
  private String onFull;

  public static final String JSON_PROPERTY_TO = "to";
  private String to;

  public static final String JSON_PROPERTY_TO_VERTEX_LIMITS = "toVertexLimits";
  private VertexLimits toVertexLimits;

  public static final String JSON_PROPERTY_TO_VERTEX_PARTITION_COUNT = "toVertexPartitionCount";
  private Integer toVertexPartitionCount;

  public static final String JSON_PROPERTY_TO_VERTEX_TYPE = "toVertexType";
  private String toVertexType;

  public CombinedEdge() { 
  }

  public CombinedEdge conditions(ForwardConditions conditions) {
    this.conditions = conditions;
    return this;
  }

  /**
   * Get conditions
   * @return conditions
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_CONDITIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public ForwardConditions getConditions() {
    return conditions;
  }


  @JsonProperty(JSON_PROPERTY_CONDITIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setConditions(ForwardConditions conditions) {
    this.conditions = conditions;
  }


  public CombinedEdge from(String from) {
    this.from = from;
    return this;
  }

  /**
   * Get from
   * @return from
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_FROM)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public String getFrom() {
    return from;
  }


  @JsonProperty(JSON_PROPERTY_FROM)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setFrom(String from) {
    this.from = from;
  }


  public CombinedEdge fromVertexLimits(VertexLimits fromVertexLimits) {
    this.fromVertexLimits = fromVertexLimits;
    return this;
  }

  /**
   * Get fromVertexLimits
   * @return fromVertexLimits
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_FROM_VERTEX_LIMITS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public VertexLimits getFromVertexLimits() {
    return fromVertexLimits;
  }


  @JsonProperty(JSON_PROPERTY_FROM_VERTEX_LIMITS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setFromVertexLimits(VertexLimits fromVertexLimits) {
    this.fromVertexLimits = fromVertexLimits;
  }


  public CombinedEdge fromVertexPartitionCount(Integer fromVertexPartitionCount) {
    this.fromVertexPartitionCount = fromVertexPartitionCount;
    return this;
  }

  /**
   * The number of partitions of the from vertex, if not provided, the default value is set to \&quot;1\&quot;.
   * @return fromVertexPartitionCount
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_FROM_VERTEX_PARTITION_COUNT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Integer getFromVertexPartitionCount() {
    return fromVertexPartitionCount;
  }


  @JsonProperty(JSON_PROPERTY_FROM_VERTEX_PARTITION_COUNT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setFromVertexPartitionCount(Integer fromVertexPartitionCount) {
    this.fromVertexPartitionCount = fromVertexPartitionCount;
  }


  public CombinedEdge fromVertexType(String fromVertexType) {
    this.fromVertexType = fromVertexType;
    return this;
  }

  /**
   * From vertex type.
   * @return fromVertexType
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_FROM_VERTEX_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public String getFromVertexType() {
    return fromVertexType;
  }


  @JsonProperty(JSON_PROPERTY_FROM_VERTEX_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setFromVertexType(String fromVertexType) {
    this.fromVertexType = fromVertexType;
  }


  public CombinedEdge onFull(String onFull) {
    this.onFull = onFull;
    return this;
  }

  /**
   * OnFull specifies the behaviour for the write actions when the inter step buffer is full. There are currently two options, retryUntilSuccess and discardLatest. if not provided, the default value is set to \&quot;retryUntilSuccess\&quot;
   * @return onFull
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ON_FULL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getOnFull() {
    return onFull;
  }


  @JsonProperty(JSON_PROPERTY_ON_FULL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setOnFull(String onFull) {
    this.onFull = onFull;
  }


  public CombinedEdge to(String to) {
    this.to = to;
    return this;
  }

  /**
   * Get to
   * @return to
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_TO)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public String getTo() {
    return to;
  }


  @JsonProperty(JSON_PROPERTY_TO)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setTo(String to) {
    this.to = to;
  }


  public CombinedEdge toVertexLimits(VertexLimits toVertexLimits) {
    this.toVertexLimits = toVertexLimits;
    return this;
  }

  /**
   * Get toVertexLimits
   * @return toVertexLimits
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TO_VERTEX_LIMITS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public VertexLimits getToVertexLimits() {
    return toVertexLimits;
  }


  @JsonProperty(JSON_PROPERTY_TO_VERTEX_LIMITS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setToVertexLimits(VertexLimits toVertexLimits) {
    this.toVertexLimits = toVertexLimits;
  }


  public CombinedEdge toVertexPartitionCount(Integer toVertexPartitionCount) {
    this.toVertexPartitionCount = toVertexPartitionCount;
    return this;
  }

  /**
   * The number of partitions of the to vertex, if not provided, the default value is set to \&quot;1\&quot;.
   * @return toVertexPartitionCount
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TO_VERTEX_PARTITION_COUNT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Integer getToVertexPartitionCount() {
    return toVertexPartitionCount;
  }


  @JsonProperty(JSON_PROPERTY_TO_VERTEX_PARTITION_COUNT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setToVertexPartitionCount(Integer toVertexPartitionCount) {
    this.toVertexPartitionCount = toVertexPartitionCount;
  }


  public CombinedEdge toVertexType(String toVertexType) {
    this.toVertexType = toVertexType;
    return this;
  }

  /**
   * To vertex type.
   * @return toVertexType
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_TO_VERTEX_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public String getToVertexType() {
    return toVertexType;
  }


  @JsonProperty(JSON_PROPERTY_TO_VERTEX_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setToVertexType(String toVertexType) {
    this.toVertexType = toVertexType;
  }


  /**
   * Return true if this CombinedEdge object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CombinedEdge combinedEdge = (CombinedEdge) o;
    return Objects.equals(this.conditions, combinedEdge.conditions) &&
        Objects.equals(this.from, combinedEdge.from) &&
        Objects.equals(this.fromVertexLimits, combinedEdge.fromVertexLimits) &&
        Objects.equals(this.fromVertexPartitionCount, combinedEdge.fromVertexPartitionCount) &&
        Objects.equals(this.fromVertexType, combinedEdge.fromVertexType) &&
        Objects.equals(this.onFull, combinedEdge.onFull) &&
        Objects.equals(this.to, combinedEdge.to) &&
        Objects.equals(this.toVertexLimits, combinedEdge.toVertexLimits) &&
        Objects.equals(this.toVertexPartitionCount, combinedEdge.toVertexPartitionCount) &&
        Objects.equals(this.toVertexType, combinedEdge.toVertexType);
  }

  @Override
  public int hashCode() {
    return Objects.hash(conditions, from, fromVertexLimits, fromVertexPartitionCount, fromVertexType, onFull, to, toVertexLimits, toVertexPartitionCount, toVertexType);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CombinedEdge {\n");
    sb.append("    conditions: ").append(toIndentedString(conditions)).append("\n");
    sb.append("    from: ").append(toIndentedString(from)).append("\n");
    sb.append("    fromVertexLimits: ").append(toIndentedString(fromVertexLimits)).append("\n");
    sb.append("    fromVertexPartitionCount: ").append(toIndentedString(fromVertexPartitionCount)).append("\n");
    sb.append("    fromVertexType: ").append(toIndentedString(fromVertexType)).append("\n");
    sb.append("    onFull: ").append(toIndentedString(onFull)).append("\n");
    sb.append("    to: ").append(toIndentedString(to)).append("\n");
    sb.append("    toVertexLimits: ").append(toIndentedString(toVertexLimits)).append("\n");
    sb.append("    toVertexPartitionCount: ").append(toIndentedString(toVertexPartitionCount)).append("\n");
    sb.append("    toVertexType: ").append(toIndentedString(toVertexType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `conditions` to the URL query string
    if (getConditions() != null) {
      joiner.add(getConditions().toUrlQueryString(prefix + "conditions" + suffix));
    }

    // add `from` to the URL query string
    if (getFrom() != null) {
      joiner.add(String.format("%sfrom%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getFrom()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `fromVertexLimits` to the URL query string
    if (getFromVertexLimits() != null) {
      joiner.add(getFromVertexLimits().toUrlQueryString(prefix + "fromVertexLimits" + suffix));
    }

    // add `fromVertexPartitionCount` to the URL query string
    if (getFromVertexPartitionCount() != null) {
      joiner.add(String.format("%sfromVertexPartitionCount%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getFromVertexPartitionCount()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `fromVertexType` to the URL query string
    if (getFromVertexType() != null) {
      joiner.add(String.format("%sfromVertexType%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getFromVertexType()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `onFull` to the URL query string
    if (getOnFull() != null) {
      joiner.add(String.format("%sonFull%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getOnFull()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `to` to the URL query string
    if (getTo() != null) {
      joiner.add(String.format("%sto%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getTo()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `toVertexLimits` to the URL query string
    if (getToVertexLimits() != null) {
      joiner.add(getToVertexLimits().toUrlQueryString(prefix + "toVertexLimits" + suffix));
    }

    // add `toVertexPartitionCount` to the URL query string
    if (getToVertexPartitionCount() != null) {
      joiner.add(String.format("%stoVertexPartitionCount%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getToVertexPartitionCount()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `toVertexType` to the URL query string
    if (getToVertexType() != null) {
      joiner.add(String.format("%stoVertexType%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getToVertexType()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    return joiner.toString();
  }
}

