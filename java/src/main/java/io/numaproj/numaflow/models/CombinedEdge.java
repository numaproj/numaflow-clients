/*
 * Numaflow
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.2.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.numaproj.numaflow.models;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.numaproj.numaflow.models.ForwardConditions;
import io.numaproj.numaflow.models.VertexLimits;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


/**
 * CombinedEdge is a combination of Edge and some other properties such as vertex type, partitions, limits. It&#39;s used to decorate the fromEdges and toEdges of the generated Vertex objects, so that in the vertex pod, it knows the properties of the connected vertices, for example, how many partitioned buffers I should write to, what is the write buffer length, etc.
 */
@ApiModel(description = "CombinedEdge is a combination of Edge and some other properties such as vertex type, partitions, limits. It's used to decorate the fromEdges and toEdges of the generated Vertex objects, so that in the vertex pod, it knows the properties of the connected vertices, for example, how many partitioned buffers I should write to, what is the write buffer length, etc.")
@JsonPropertyOrder({
  CombinedEdge.JSON_PROPERTY_CONDITIONS,
  CombinedEdge.JSON_PROPERTY_FROM,
  CombinedEdge.JSON_PROPERTY_FROM_VERTEX_LIMITS,
  CombinedEdge.JSON_PROPERTY_FROM_VERTEX_PARTITION_COUNT,
  CombinedEdge.JSON_PROPERTY_FROM_VERTEX_TYPE,
  CombinedEdge.JSON_PROPERTY_ON_FULL,
  CombinedEdge.JSON_PROPERTY_TO,
  CombinedEdge.JSON_PROPERTY_TO_VERTEX_LIMITS,
  CombinedEdge.JSON_PROPERTY_TO_VERTEX_PARTITION_COUNT,
  CombinedEdge.JSON_PROPERTY_TO_VERTEX_TYPE
})
@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class CombinedEdge {
  public static final String JSON_PROPERTY_CONDITIONS = "conditions";
  private ForwardConditions conditions;

  public static final String JSON_PROPERTY_FROM = "from";
  private String from;

  public static final String JSON_PROPERTY_FROM_VERTEX_LIMITS = "fromVertexLimits";
  private VertexLimits fromVertexLimits;

  public static final String JSON_PROPERTY_FROM_VERTEX_PARTITION_COUNT = "fromVertexPartitionCount";
  private Integer fromVertexPartitionCount;

  public static final String JSON_PROPERTY_FROM_VERTEX_TYPE = "fromVertexType";
  private String fromVertexType;

  public static final String JSON_PROPERTY_ON_FULL = "onFull";
  private String onFull;

  public static final String JSON_PROPERTY_TO = "to";
  private String to;

  public static final String JSON_PROPERTY_TO_VERTEX_LIMITS = "toVertexLimits";
  private VertexLimits toVertexLimits;

  public static final String JSON_PROPERTY_TO_VERTEX_PARTITION_COUNT = "toVertexPartitionCount";
  private Integer toVertexPartitionCount;

  public static final String JSON_PROPERTY_TO_VERTEX_TYPE = "toVertexType";
  private String toVertexType;


  public CombinedEdge conditions(ForwardConditions conditions) {
    this.conditions = conditions;
    return this;
  }

   /**
   * Get conditions
   * @return conditions
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_CONDITIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public ForwardConditions getConditions() {
    return conditions;
  }


  @JsonProperty(JSON_PROPERTY_CONDITIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setConditions(ForwardConditions conditions) {
    this.conditions = conditions;
  }


  public CombinedEdge from(String from) {
    this.from = from;
    return this;
  }

   /**
   * Get from
   * @return from
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(JSON_PROPERTY_FROM)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getFrom() {
    return from;
  }


  @JsonProperty(JSON_PROPERTY_FROM)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setFrom(String from) {
    this.from = from;
  }


  public CombinedEdge fromVertexLimits(VertexLimits fromVertexLimits) {
    this.fromVertexLimits = fromVertexLimits;
    return this;
  }

   /**
   * Get fromVertexLimits
   * @return fromVertexLimits
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_FROM_VERTEX_LIMITS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public VertexLimits getFromVertexLimits() {
    return fromVertexLimits;
  }


  @JsonProperty(JSON_PROPERTY_FROM_VERTEX_LIMITS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setFromVertexLimits(VertexLimits fromVertexLimits) {
    this.fromVertexLimits = fromVertexLimits;
  }


  public CombinedEdge fromVertexPartitionCount(Integer fromVertexPartitionCount) {
    this.fromVertexPartitionCount = fromVertexPartitionCount;
    return this;
  }

   /**
   * The number of partitions of the from vertex, if not provided, the default value is set to \&quot;1\&quot;.
   * @return fromVertexPartitionCount
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The number of partitions of the from vertex, if not provided, the default value is set to \"1\".")
  @JsonProperty(JSON_PROPERTY_FROM_VERTEX_PARTITION_COUNT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getFromVertexPartitionCount() {
    return fromVertexPartitionCount;
  }


  @JsonProperty(JSON_PROPERTY_FROM_VERTEX_PARTITION_COUNT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setFromVertexPartitionCount(Integer fromVertexPartitionCount) {
    this.fromVertexPartitionCount = fromVertexPartitionCount;
  }


  public CombinedEdge fromVertexType(String fromVertexType) {
    this.fromVertexType = fromVertexType;
    return this;
  }

   /**
   * From vertex type.
   * @return fromVertexType
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "From vertex type.")
  @JsonProperty(JSON_PROPERTY_FROM_VERTEX_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getFromVertexType() {
    return fromVertexType;
  }


  @JsonProperty(JSON_PROPERTY_FROM_VERTEX_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setFromVertexType(String fromVertexType) {
    this.fromVertexType = fromVertexType;
  }


  public CombinedEdge onFull(String onFull) {
    this.onFull = onFull;
    return this;
  }

   /**
   * OnFull specifies the behaviour for the write actions when the inter step buffer is full. There are currently two options, retryUntilSuccess and discardLatest. if not provided, the default value is set to \&quot;retryUntilSuccess\&quot;
   * @return onFull
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "OnFull specifies the behaviour for the write actions when the inter step buffer is full. There are currently two options, retryUntilSuccess and discardLatest. if not provided, the default value is set to \"retryUntilSuccess\"")
  @JsonProperty(JSON_PROPERTY_ON_FULL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getOnFull() {
    return onFull;
  }


  @JsonProperty(JSON_PROPERTY_ON_FULL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setOnFull(String onFull) {
    this.onFull = onFull;
  }


  public CombinedEdge to(String to) {
    this.to = to;
    return this;
  }

   /**
   * Get to
   * @return to
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(JSON_PROPERTY_TO)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getTo() {
    return to;
  }


  @JsonProperty(JSON_PROPERTY_TO)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setTo(String to) {
    this.to = to;
  }


  public CombinedEdge toVertexLimits(VertexLimits toVertexLimits) {
    this.toVertexLimits = toVertexLimits;
    return this;
  }

   /**
   * Get toVertexLimits
   * @return toVertexLimits
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_TO_VERTEX_LIMITS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public VertexLimits getToVertexLimits() {
    return toVertexLimits;
  }


  @JsonProperty(JSON_PROPERTY_TO_VERTEX_LIMITS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setToVertexLimits(VertexLimits toVertexLimits) {
    this.toVertexLimits = toVertexLimits;
  }


  public CombinedEdge toVertexPartitionCount(Integer toVertexPartitionCount) {
    this.toVertexPartitionCount = toVertexPartitionCount;
    return this;
  }

   /**
   * The number of partitions of the to vertex, if not provided, the default value is set to \&quot;1\&quot;.
   * @return toVertexPartitionCount
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The number of partitions of the to vertex, if not provided, the default value is set to \"1\".")
  @JsonProperty(JSON_PROPERTY_TO_VERTEX_PARTITION_COUNT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getToVertexPartitionCount() {
    return toVertexPartitionCount;
  }


  @JsonProperty(JSON_PROPERTY_TO_VERTEX_PARTITION_COUNT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setToVertexPartitionCount(Integer toVertexPartitionCount) {
    this.toVertexPartitionCount = toVertexPartitionCount;
  }


  public CombinedEdge toVertexType(String toVertexType) {
    this.toVertexType = toVertexType;
    return this;
  }

   /**
   * To vertex type.
   * @return toVertexType
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "To vertex type.")
  @JsonProperty(JSON_PROPERTY_TO_VERTEX_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getToVertexType() {
    return toVertexType;
  }


  @JsonProperty(JSON_PROPERTY_TO_VERTEX_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setToVertexType(String toVertexType) {
    this.toVertexType = toVertexType;
  }


  /**
   * Return true if this CombinedEdge object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CombinedEdge combinedEdge = (CombinedEdge) o;
    return Objects.equals(this.conditions, combinedEdge.conditions) &&
        Objects.equals(this.from, combinedEdge.from) &&
        Objects.equals(this.fromVertexLimits, combinedEdge.fromVertexLimits) &&
        Objects.equals(this.fromVertexPartitionCount, combinedEdge.fromVertexPartitionCount) &&
        Objects.equals(this.fromVertexType, combinedEdge.fromVertexType) &&
        Objects.equals(this.onFull, combinedEdge.onFull) &&
        Objects.equals(this.to, combinedEdge.to) &&
        Objects.equals(this.toVertexLimits, combinedEdge.toVertexLimits) &&
        Objects.equals(this.toVertexPartitionCount, combinedEdge.toVertexPartitionCount) &&
        Objects.equals(this.toVertexType, combinedEdge.toVertexType);
  }

  @Override
  public int hashCode() {
    return Objects.hash(conditions, from, fromVertexLimits, fromVertexPartitionCount, fromVertexType, onFull, to, toVertexLimits, toVertexPartitionCount, toVertexType);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CombinedEdge {\n");
    sb.append("    conditions: ").append(toIndentedString(conditions)).append("\n");
    sb.append("    from: ").append(toIndentedString(from)).append("\n");
    sb.append("    fromVertexLimits: ").append(toIndentedString(fromVertexLimits)).append("\n");
    sb.append("    fromVertexPartitionCount: ").append(toIndentedString(fromVertexPartitionCount)).append("\n");
    sb.append("    fromVertexType: ").append(toIndentedString(fromVertexType)).append("\n");
    sb.append("    onFull: ").append(toIndentedString(onFull)).append("\n");
    sb.append("    to: ").append(toIndentedString(to)).append("\n");
    sb.append("    toVertexLimits: ").append(toIndentedString(toVertexLimits)).append("\n");
    sb.append("    toVertexPartitionCount: ").append(toIndentedString(toVertexPartitionCount)).append("\n");
    sb.append("    toVertexType: ").append(toIndentedString(toVertexType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

